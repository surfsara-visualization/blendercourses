{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"1. Introduction \u00b6 In this course you will learn the basics of the Python API in Blender. You will learn how the API is structured and eventually start making some simple geometry with code. Another important part of the course is that you will work on a visualisation based on your own research or other endeavours. 1.1 Course setup \u00b6 Let us briefly explain how we think you can get the most out of this course. This tutorial is set-up in such a way that you should work through it by yourself. This tutorial contains theory, exercises and links to instructional videos for you to watch. Read and watch the materials first and then do the exercises. Also try to reproduce all the steps and theory explained in this tutorial and in the videos yourself. When done, follow with the last project exercise at the end of the tutorial. You can ask questions in our Discord channel if you get stuck. During course times we also organize webinars during which you can present you project and ask for feedback. See the course website on how to join our Discord and how to register for the webinars. 1.2 Blender version \u00b6 Blender as a software package is always in development, with new features and bug fixes in every release throughout the year. This also means that there might be small differences in the version of Blender you're using compared to these course notes. Here, we assume Blender 2.83 LTS 1.3 About \u00b6 SURF (collaborative organisation for compute in Dutch education and research) offers courses on several topics within the PRACE Partnership . This website accompanies courses from the Visualisation team focused on using Blender , the free and open source 3D creation suite, for scientific goals. This course is organized as part of PRACE Training Centre activities. Questions and/or remarks on this course can be sent to training@surfsara.nl .","title":"Introduction"},{"location":"#1-introduction","text":"In this course you will learn the basics of the Python API in Blender. You will learn how the API is structured and eventually start making some simple geometry with code. Another important part of the course is that you will work on a visualisation based on your own research or other endeavours.","title":"1. Introduction"},{"location":"#11-course-setup","text":"Let us briefly explain how we think you can get the most out of this course. This tutorial is set-up in such a way that you should work through it by yourself. This tutorial contains theory, exercises and links to instructional videos for you to watch. Read and watch the materials first and then do the exercises. Also try to reproduce all the steps and theory explained in this tutorial and in the videos yourself. When done, follow with the last project exercise at the end of the tutorial. You can ask questions in our Discord channel if you get stuck. During course times we also organize webinars during which you can present you project and ask for feedback. See the course website on how to join our Discord and how to register for the webinars.","title":"1.1 Course setup"},{"location":"#12-blender-version","text":"Blender as a software package is always in development, with new features and bug fixes in every release throughout the year. This also means that there might be small differences in the version of Blender you're using compared to these course notes. Here, we assume Blender 2.83 LTS","title":"1.2 Blender version"},{"location":"#13-about","text":"SURF (collaborative organisation for compute in Dutch education and research) offers courses on several topics within the PRACE Partnership . This website accompanies courses from the Visualisation team focused on using Blender , the free and open source 3D creation suite, for scientific goals. This course is organized as part of PRACE Training Centre activities. Questions and/or remarks on this course can be sent to training@surfsara.nl .","title":"1.3 About"},{"location":"Tutorial_protoplanetary_disk_scientific_model_in_Blender/","text":"Python scripting for Blender - A case study \u00b6 A scientific visualisation with Blender 1. Introduction & goals \u00b6 1.1 What we will visualise: a proto-planetary disk \u00b6 A proto-planetary disk is a disk-like structure around a newly born star. This disk is filled with dust (solid-state particles with a diameter in the order of 1 micrometer) and gas. In the course of time this dust and gas can coallesce into planets. In this case-study we will look at a model (called MCMax) of the dust in such a disk. The model calculates the temperature and density of the dust in the disk, taking the radiation and gravity of the star into account. Using the temperature and density the code can then calculate the light radiation coming from the disk as if observed with a telescope using ray-tracing. The calculations of MCMax is done iteratively and using Monte Carlo techniques. Packages of photons are emitted by the star in random directions and their wavelength sampled from the radiation distribution of the star (by default a blackbody). Using the absorption, scattering and emission properties used for the dust grains in the disk, the scattering, absorption and re-emission of the photons are calculated throughout the disk. This is used to calculate a temperature structure in the disk. This temperature is then used to adapt the starting density structure of the disk after which a new pass is done by tracking a next set of photons and adapting the density subsequenty. This is repeated until convergence is reached. The code uses a two dimentional grid in the radial and theta direction. The disk is assumed to be cylindrically symmetric around the polar axis. The grid cell size is lowered in regions where the density becomes high. 1.2 How will we visualise such a proto-planetary disk \u00b6 We would like to create a 3D model of the disk at constant density and display the temperature as colors on the surface of the model (see sketch in Fig. X). We could use this to make nice renders and animations to show the temperature structure of the disk. For this we need to pre-process the data from the model to get the spatial coordinates of the disk at a constant density. These coordinates then need to be converted into vertices, edges and faces before creating the geometry in Blender. We will then add the temperatures to the faces using vertex coloring by adding the needed shaders to the model. We will start by exploring and pre-processing the data in the next section. Figure X: Sketch of the Blender model we want to make. Indicate cutout surfaces and disk surface. Also indicate spherical and cartesian coordinates. 2. Exploring the example data \u00b6 2.1 How the model data is structured \u00b6 An example output file of modeling code MCMax is shown below. # Format number 5 # NR , NT , NGRAINS , NGRAINS2 100 100 1 1 # Spherical radius grid [ cm ] ( middle of cell ) 7479900216981.22 7479900572789.07 [ ... ] # Theta grid [ rad, from pole ] ( middle of cell ) 9.233559849414326E-003 2.365344804038962E-002 [ ... ] # Density array ( for ir = 0 , nr - 1 do for it = 0 , nt - 1 do ...) 1.001753516582521E-050 1.001753516582521E-050 [ ... ] # Temperature array ( for ir = 0 , nr - 1 do for it = 0 , nt - 1 do ...) 1933.54960366819 1917.22966277529 [ ... ] # Composition array ( for ir = 0 , nr - 1 do for it = 0 , nt - 1 do ...) 1.00000000000000 1.00000000000000 [ ... ] # Gas density array ( for ir = 0 , nr - 1 do for it = 0 , nt - 1 do ...) 1.001753516582521E-048 1.001753516582521E-048 [ ... ] # Density0 array ( for ir = 0 , nr - 1 do for it = 0 , nt - 1 do ...) 1.001753516582521E-050 1.001753516582521E-050 [ ... ] The file is structured in a way the scientist thought best at the time using the tools at hand. For us it is important to notice the NR and NT , which stands for number of radial and theta points respectively (NGRAINS is related to the number of different type of dust grains in the disk and we will not work with this for now). Further, the output file then lists the radius points and after that the theta points. Subsequently temperature and density values are listed by iterating over the radius and then the theta indices. The units of all the values in the MCMax output are: R[cm], Theta[radians], Density[gr/cm^3], Temperature[K]. We can make a function to read in the output file of the MCMax code like this: def readInMCMaxFile ( filepath ): denstemp_file = open ( filepath , \"r\" ) # Header information on first 3 lines header = [ denstemp_file . readline () for i in range ( 3 )] # One line contains grid information Nrad , Ntheta , nGrains , nGrains2 = [ int ( i ) for i in denstemp_file . readline () . split ()] denstemp_file . readline () # Non-data line # Read in radius grid R = [ float ( denstemp_file . readline ()) / AU for i in range ( Nrad )] denstemp_file . readline () # Non-data line # Read in theta grid Th = [ float ( denstemp_file . readline ()) / ( 2 * math . pi ) * 360 for i in range ( Ntheta )] denstemp_file . readline () # Non-data line # Read in density rho = [ [ float ( denstemp_file . readline ()) * scale_density for j in range ( Ntheta )] for i in range ( Nrad )] denstemp_file . readline () # Non-data line # Read in temperature temp = [ [ float ( denstemp_file . readline ()) for j in range ( Ntheta )] for i in range ( Nrad )] denstemp_file . readline () # Non-data line denstemp_file . close () return Nrad , Ntheta , R , Th , rho , temp Here we convert theta from radians to degrees and the radius from cm to astronomical units (AU, one times the distance between the Sun and Earth). We now have the data in lists and we are ready to process them to values we can use in Blender. 2.2 Pre-processing the data \u00b6 Converting the coordinates The data from the MCMax code is in spherical coordinates, while the system in Blender works with cartesian coordinates. The theta in the output is defined as the angle with the z-axis. We define phi as the angle from the x-axis. In this way we can convert from spherical coordinates to cartesian: def getCartCoord ( R , th , ph ): x = math . sin ( ph / 360 * 2 * math . pi ) * math . sin ( th / 360 * 2 * math . pi ) * R y = math . cos ( ph / 360 * 2 * math . pi ) * math . sin ( th / 360 * 2 * math . pi ) * R z = math . cos ( th / 360 * 2 * math . pi ) * R return x , y , z Figure X: Definition of coordinates. Exercise 2.1: Inspecting the data Make a plot from the datsa .... Making isosurfaces for density and other parameters Creating vertices and edges Making faces using fill_holes() Creating vertex colors for the temperature data","title":"<span style=\"color:#00abe9\">Python scripting for Blender - A case study</span>"},{"location":"Tutorial_protoplanetary_disk_scientific_model_in_Blender/#python-scripting-for-blender-a-case-study","text":"A scientific visualisation with Blender","title":"Python scripting for Blender - A case study"},{"location":"Tutorial_protoplanetary_disk_scientific_model_in_Blender/#1-introduction-goals","text":"","title":"1. Introduction &amp; goals"},{"location":"Tutorial_protoplanetary_disk_scientific_model_in_Blender/#11-what-we-will-visualise-a-proto-planetary-disk","text":"A proto-planetary disk is a disk-like structure around a newly born star. This disk is filled with dust (solid-state particles with a diameter in the order of 1 micrometer) and gas. In the course of time this dust and gas can coallesce into planets. In this case-study we will look at a model (called MCMax) of the dust in such a disk. The model calculates the temperature and density of the dust in the disk, taking the radiation and gravity of the star into account. Using the temperature and density the code can then calculate the light radiation coming from the disk as if observed with a telescope using ray-tracing. The calculations of MCMax is done iteratively and using Monte Carlo techniques. Packages of photons are emitted by the star in random directions and their wavelength sampled from the radiation distribution of the star (by default a blackbody). Using the absorption, scattering and emission properties used for the dust grains in the disk, the scattering, absorption and re-emission of the photons are calculated throughout the disk. This is used to calculate a temperature structure in the disk. This temperature is then used to adapt the starting density structure of the disk after which a new pass is done by tracking a next set of photons and adapting the density subsequenty. This is repeated until convergence is reached. The code uses a two dimentional grid in the radial and theta direction. The disk is assumed to be cylindrically symmetric around the polar axis. The grid cell size is lowered in regions where the density becomes high.","title":"1.1 What we will visualise: a proto-planetary disk"},{"location":"Tutorial_protoplanetary_disk_scientific_model_in_Blender/#12-how-will-we-visualise-such-a-proto-planetary-disk","text":"We would like to create a 3D model of the disk at constant density and display the temperature as colors on the surface of the model (see sketch in Fig. X). We could use this to make nice renders and animations to show the temperature structure of the disk. For this we need to pre-process the data from the model to get the spatial coordinates of the disk at a constant density. These coordinates then need to be converted into vertices, edges and faces before creating the geometry in Blender. We will then add the temperatures to the faces using vertex coloring by adding the needed shaders to the model. We will start by exploring and pre-processing the data in the next section. Figure X: Sketch of the Blender model we want to make. Indicate cutout surfaces and disk surface. Also indicate spherical and cartesian coordinates.","title":"1.2 How will we visualise such a proto-planetary disk"},{"location":"Tutorial_protoplanetary_disk_scientific_model_in_Blender/#2-exploring-the-example-data","text":"","title":"2. Exploring the example data"},{"location":"Tutorial_protoplanetary_disk_scientific_model_in_Blender/#21-how-the-model-data-is-structured","text":"An example output file of modeling code MCMax is shown below. # Format number 5 # NR , NT , NGRAINS , NGRAINS2 100 100 1 1 # Spherical radius grid [ cm ] ( middle of cell ) 7479900216981.22 7479900572789.07 [ ... ] # Theta grid [ rad, from pole ] ( middle of cell ) 9.233559849414326E-003 2.365344804038962E-002 [ ... ] # Density array ( for ir = 0 , nr - 1 do for it = 0 , nt - 1 do ...) 1.001753516582521E-050 1.001753516582521E-050 [ ... ] # Temperature array ( for ir = 0 , nr - 1 do for it = 0 , nt - 1 do ...) 1933.54960366819 1917.22966277529 [ ... ] # Composition array ( for ir = 0 , nr - 1 do for it = 0 , nt - 1 do ...) 1.00000000000000 1.00000000000000 [ ... ] # Gas density array ( for ir = 0 , nr - 1 do for it = 0 , nt - 1 do ...) 1.001753516582521E-048 1.001753516582521E-048 [ ... ] # Density0 array ( for ir = 0 , nr - 1 do for it = 0 , nt - 1 do ...) 1.001753516582521E-050 1.001753516582521E-050 [ ... ] The file is structured in a way the scientist thought best at the time using the tools at hand. For us it is important to notice the NR and NT , which stands for number of radial and theta points respectively (NGRAINS is related to the number of different type of dust grains in the disk and we will not work with this for now). Further, the output file then lists the radius points and after that the theta points. Subsequently temperature and density values are listed by iterating over the radius and then the theta indices. The units of all the values in the MCMax output are: R[cm], Theta[radians], Density[gr/cm^3], Temperature[K]. We can make a function to read in the output file of the MCMax code like this: def readInMCMaxFile ( filepath ): denstemp_file = open ( filepath , \"r\" ) # Header information on first 3 lines header = [ denstemp_file . readline () for i in range ( 3 )] # One line contains grid information Nrad , Ntheta , nGrains , nGrains2 = [ int ( i ) for i in denstemp_file . readline () . split ()] denstemp_file . readline () # Non-data line # Read in radius grid R = [ float ( denstemp_file . readline ()) / AU for i in range ( Nrad )] denstemp_file . readline () # Non-data line # Read in theta grid Th = [ float ( denstemp_file . readline ()) / ( 2 * math . pi ) * 360 for i in range ( Ntheta )] denstemp_file . readline () # Non-data line # Read in density rho = [ [ float ( denstemp_file . readline ()) * scale_density for j in range ( Ntheta )] for i in range ( Nrad )] denstemp_file . readline () # Non-data line # Read in temperature temp = [ [ float ( denstemp_file . readline ()) for j in range ( Ntheta )] for i in range ( Nrad )] denstemp_file . readline () # Non-data line denstemp_file . close () return Nrad , Ntheta , R , Th , rho , temp Here we convert theta from radians to degrees and the radius from cm to astronomical units (AU, one times the distance between the Sun and Earth). We now have the data in lists and we are ready to process them to values we can use in Blender.","title":"2.1 How the model data is structured"},{"location":"Tutorial_protoplanetary_disk_scientific_model_in_Blender/#22-pre-processing-the-data","text":"","title":"2.2 Pre-processing the data"},{"location":"Tutorial_something_more/","text":"Python scripting for Blender - extra topics \u00b6 1. The Blender context and python scripting \u00b6 1.1 Access the Blender context \u00b6 User context: Based on what is selected by the user bpy.context.object 2 Using and making operators \u00b6 Adding an operator through classes: import bpy class SimpleOperator ( bpy . types . Operator ): bl_idname = \"object.simple_operator\" # USED IN bpy.ops.object bl_label = \"Tool Name\" # USED BY OPERATOR SEARCH (spacebar, F3) def execute ( self , context ): print ( \"Hello World\" ) return { 'FINISHED' } bpy . utils . register_class ( SimpleOperator ) Misc Blender items \u00b6 Adding a background \u00b6 Go to World Properties Click on the circle next to 'Color' and choose 'Image Texture' Change 'Repeat' into 'Clip' Click on the circle next to 'Vector' - 'default' and set it to 'Window' See also: https://henryegloff.com/how-to-render-a-background-image-in-blender-2-8-using-the-document-world-settings/","title":"<span style=\"color:#00abe9\">Python scripting for Blender - extra topics</span>"},{"location":"Tutorial_something_more/#python-scripting-for-blender-extra-topics","text":"","title":"Python scripting for Blender - extra topics"},{"location":"Tutorial_something_more/#1-the-blender-context-and-python-scripting","text":"","title":"1. The Blender context and python scripting"},{"location":"Tutorial_something_more/#11-access-the-blender-context","text":"User context: Based on what is selected by the user bpy.context.object","title":"1.1 Access the Blender context"},{"location":"Tutorial_something_more/#2-using-and-making-operators","text":"Adding an operator through classes: import bpy class SimpleOperator ( bpy . types . Operator ): bl_idname = \"object.simple_operator\" # USED IN bpy.ops.object bl_label = \"Tool Name\" # USED BY OPERATOR SEARCH (spacebar, F3) def execute ( self , context ): print ( \"Hello World\" ) return { 'FINISHED' } bpy . utils . register_class ( SimpleOperator )","title":"2 Using and making operators"},{"location":"Tutorial_something_more/#misc-blender-items","text":"","title":"Misc Blender items"},{"location":"Tutorial_something_more/#adding-a-background","text":"Go to World Properties Click on the circle next to 'Color' and choose 'Image Texture' Change 'Repeat' into 'Clip' Click on the circle next to 'Vector' - 'default' and set it to 'Window' See also: https://henryegloff.com/how-to-render-a-background-image-in-blender-2-8-using-the-document-world-settings/","title":"Adding a background"},{"location":"accessing_data/","text":"3. Accessing Blender data \u00b6 3.1 Using bpy.data \u00b6 All data in a Blender file can be accessed through bpy.data . This contains for example all objects ( bpy.data.objects ), all meshes ( bpy.data.meshes ), all scenes ( bpy.data.scenes ) and all materials ( bpy.data.materials ). The data is stored in a data-type called bpy_collection whose members (data blocks) can be accessed with both an index as well as a string (this in contrary to regular Python dictionaries). For example. bpy.data.objects[\"Cube\"] and bpy.data.objects[1] will be equivalent if Cube is the second object in the collection. Attributes of data blocks (e.g an object, collection or material) can be accessed with a period. For example: >>> bpy . data . objects [ 0 ] . name 'Camera' Two examples of changing attributes (note that some operations only work if Blender is in the right mode): bpy . data . objects [ \"Cube\" ] . location . z += 1 # this works in both edit and object mode bpy . data . objects [ \"Cube\" ] . data . vertices [ 0 ] . co . z += 10 # this works only in object mode Tips Use the Python Console in Blender and the auto-complete functionality to see what attributes bpy.data has. The Info Editor in Blender shows the python commands being executed when you do operations manually in Blender (See Fig. 2.) Hovering over buttons and input boxes in Blender shows how to access the underlying values through the Python API. Figure 2: The Info Editor is a nice way to see what python commands are executed when you use Blender. In this figure we see that we deleted the initial cube, made a UV Sphere and translated it. 3.2 Some notes on bpy.context and bpy.ops \u00b6 In this section we want to briefly introduce how you can access the so-called context and use operators in the Blender Python API. bpy.context stores information about a user's selections and the context Blender is in. For example, if you want to check which mode is currently active in Blender you can check the value of bpy.context.mode . Now if you want to change the mode, you can use an operator. Operators are tools that are usually accessed through the user interface with buttons and menus. You can access these operators with Python through bpy.ops . If we would like to change the mode we can do this using an operator, e.g. bpy.ops.object.mode_set(mode='OBJECT') Of course switching to, say, edit mode, depends on which object are selected, which can be checked with bpy.context.selected_objects . But keep in mind that many of the variables in the context are read-only, altering bpy.context.selected_objects directly is not possible. Instead, you can select an object with the select_set() method of the object, e.g. bpy.data.objects['Cube'].select_set(True) . 3.3 Exercise 2: running a script and rendering from the console \u00b6 Write an external script that removes the Cube object that is part of the default scene 1 Then, from the command line and without opening the Blender GUI execute this script and render the first frame. Let it output a PNG image file in the directory of the blender file. Was the cube indeed removed from the rendered image? Extra question: is the cube removed from the blender file? Although you might have altered your startup scene to not have the cube \u21a9","title":"Accessing Blender data"},{"location":"accessing_data/#3-accessing-blender-data","text":"","title":"3. Accessing Blender data"},{"location":"accessing_data/#31-using-bpydata","text":"All data in a Blender file can be accessed through bpy.data . This contains for example all objects ( bpy.data.objects ), all meshes ( bpy.data.meshes ), all scenes ( bpy.data.scenes ) and all materials ( bpy.data.materials ). The data is stored in a data-type called bpy_collection whose members (data blocks) can be accessed with both an index as well as a string (this in contrary to regular Python dictionaries). For example. bpy.data.objects[\"Cube\"] and bpy.data.objects[1] will be equivalent if Cube is the second object in the collection. Attributes of data blocks (e.g an object, collection or material) can be accessed with a period. For example: >>> bpy . data . objects [ 0 ] . name 'Camera' Two examples of changing attributes (note that some operations only work if Blender is in the right mode): bpy . data . objects [ \"Cube\" ] . location . z += 1 # this works in both edit and object mode bpy . data . objects [ \"Cube\" ] . data . vertices [ 0 ] . co . z += 10 # this works only in object mode Tips Use the Python Console in Blender and the auto-complete functionality to see what attributes bpy.data has. The Info Editor in Blender shows the python commands being executed when you do operations manually in Blender (See Fig. 2.) Hovering over buttons and input boxes in Blender shows how to access the underlying values through the Python API. Figure 2: The Info Editor is a nice way to see what python commands are executed when you use Blender. In this figure we see that we deleted the initial cube, made a UV Sphere and translated it.","title":"3.1 Using bpy.data"},{"location":"accessing_data/#32-some-notes-on-bpycontext-and-bpyops","text":"In this section we want to briefly introduce how you can access the so-called context and use operators in the Blender Python API. bpy.context stores information about a user's selections and the context Blender is in. For example, if you want to check which mode is currently active in Blender you can check the value of bpy.context.mode . Now if you want to change the mode, you can use an operator. Operators are tools that are usually accessed through the user interface with buttons and menus. You can access these operators with Python through bpy.ops . If we would like to change the mode we can do this using an operator, e.g. bpy.ops.object.mode_set(mode='OBJECT') Of course switching to, say, edit mode, depends on which object are selected, which can be checked with bpy.context.selected_objects . But keep in mind that many of the variables in the context are read-only, altering bpy.context.selected_objects directly is not possible. Instead, you can select an object with the select_set() method of the object, e.g. bpy.data.objects['Cube'].select_set(True) .","title":"3.2 Some notes on bpy.context and bpy.ops"},{"location":"accessing_data/#33-exercise-2-running-a-script-and-rendering-from-the-console","text":"Write an external script that removes the Cube object that is part of the default scene 1 Then, from the command line and without opening the Blender GUI execute this script and render the first frame. Let it output a PNG image file in the directory of the blender file. Was the cube indeed removed from the rendered image? Extra question: is the cube removed from the blender file? Although you might have altered your startup scene to not have the cube \u21a9","title":"3.3 Exercise 2: running a script and rendering from the console"},{"location":"answers/","text":"Exercise 1: starting Blender from the console \u00b6 Find the Blender executable on the machine you are working on. Open Blender through the console. Delete the cube in the default project of Blender, what output is shown in the console? Exercise 2: running a script and rendering from the console \u00b6 Write an external script that removes the Cube object that is part of the default scene [^1] Then, from the command line and without opening the Blender GUI execute this script and render the first frame. Let it output a PNG image file in the directory of the blender file. Was the cube indeed removed from the rendered image? Extra question: is the cube removed from the blender file? Answer: import bpy bpy . data . objects [ 'Cube' ] . select_set ( True ) bpy . ops . object . delete () # OR: bpy.data.objects.remove(bpy.data.objects[\"Cube\"]) blender -b test.blend -o .//render_ -F PNG -P test.py -f 1 Exercise 3: a filled disc from scratch \u00b6 In the text above we created a triangle, now as an exercise let's create a spherical disk. First create a ring of vertices, then create edges and a face. Answer: import bpy import math X = [ math . sin ( a ) for a in [ p / 360 * 2 * math . pi for p in range ( 360 )]] Y = [ math . cos ( a ) for a in [ p / 360 * 2 * math . pi for p in range ( 360 )]] verts = [( x , y , 0 ) for x , y in zip ( X , Y )] edges = [( iv , iv + 1 ) for iv in range ( len ( verts ) - 1 )] faces = [ range ( len ( verts ))] mesh = bpy . data . meshes . new ( \"disk_mesh\" ) ob = bpy . data . objects . new ( \"disk\" , mesh ) mesh . from_pydata ( verts , edges , faces ) bpy . context . collection . objects . link ( ob ) Exercise 4: making triangles and make a vertex color layer \u00b6 Let's take the triangle we made in section 4.1, but let's add another triangle to it, attached to the first. The code would look like this: import bpy # Create a new mesh ob_name = \"triangle\" mesh = bpy . data . meshes . new ( ob_name + \"_mesh\" ) # Create a new object with the mesh ob = bpy . data . objects . new ( ob_name , mesh ) # Define some geometry verts = [ ( 0 , 0 , 0 ), ( 0 , 2 , 0 ), ( 0 , 1 , 2 ) , ( 0 , 3 , 2 ) ] edges = [ ( 0 , 1 ), ( 1 , 2 ), ( 2 , 0 ), ( 1 , 3 ), ( 3 , 2 ) ] # These are indices pointing to elements in the list verts faces = [ ( 0 , 1 , 2 ), ( 1 , 3 , 2 ) ] # These are indices pointing to elements in the list verts # Add it to the mesh mesh . from_pydata ( verts , edges , faces ) # Link the object to the first collection bpy . data . collections [ 0 ] . objects . link ( ob ) Now make a vertex color layer for your triangles. Then inspect how many entries are in color_layer = mesh.vertex_colors['vert_colors'] . Why are they the same or different from the total number of vertices in the mesh? Answer: vertex_colors_name = \"vert_colors\" mesh . vertex_colors . new ( name = vertex_colors_name ) color_layer = mesh . vertex_colors [ vertex_colors_name ] >>> len ( color_layer . data ) 6 Exercise 5: coloring your triangles \u00b6 Let's take the two connected triangles of exercise 4. We will color them in two different ways, using vertex coloring and Python scripting. a) Make the first triangle (face (0,1,2)) green and the second (face (1,3,2)) red. b) Now color vertex (0,0,0) and (0,3,2) red and (0,2,0) and (0,1,2) green to make it look like in Fig.4. Answer: if exercise == \"a\" : vert_colors = [ [ 0 , 1 , 0 , 1 ], [ 0 , 1 , 0 , 1 ], [ 0 , 1 , 0 , 1 ], [ 1 , 0 , 0 , 1 ], [ 1 , 0 , 0 , 1 ] , [ 1 , 0 , 0 , 1 ] ] else : vert_colors = [ [ 1 , 0 , 0 , 1 ], [ 0 , 1 , 0 , 1 ], [ 0 , 1 , 0 , 1 ], [ 1 , 0 , 0 , 1 ] ] for poly in mesh . polygons : for vert_i_poly , vert_i_mesh in enumerate ( poly . vertices ): #loop_indices: vert_i_loop = poly . loop_indices [ vert_i_poly ] if exercise == \"a\" : color_layer . data [ vert_i_loop ] . color = vert_colors [ vert_i_loop ] #rgb else : color_layer . data [ vert_i_loop ] . color = vert_colors [ vert_i_mesh ] print ( poly , vert_i_poly , vert_i_mesh )","title":"Answers"},{"location":"answers/#exercise-1-starting-blender-from-the-console","text":"Find the Blender executable on the machine you are working on. Open Blender through the console. Delete the cube in the default project of Blender, what output is shown in the console?","title":"Exercise 1: starting Blender from the console"},{"location":"answers/#exercise-2-running-a-script-and-rendering-from-the-console","text":"Write an external script that removes the Cube object that is part of the default scene [^1] Then, from the command line and without opening the Blender GUI execute this script and render the first frame. Let it output a PNG image file in the directory of the blender file. Was the cube indeed removed from the rendered image? Extra question: is the cube removed from the blender file? Answer: import bpy bpy . data . objects [ 'Cube' ] . select_set ( True ) bpy . ops . object . delete () # OR: bpy.data.objects.remove(bpy.data.objects[\"Cube\"]) blender -b test.blend -o .//render_ -F PNG -P test.py -f 1","title":"Exercise 2: running a script and rendering from the console"},{"location":"answers/#exercise-3-a-filled-disc-from-scratch","text":"In the text above we created a triangle, now as an exercise let's create a spherical disk. First create a ring of vertices, then create edges and a face. Answer: import bpy import math X = [ math . sin ( a ) for a in [ p / 360 * 2 * math . pi for p in range ( 360 )]] Y = [ math . cos ( a ) for a in [ p / 360 * 2 * math . pi for p in range ( 360 )]] verts = [( x , y , 0 ) for x , y in zip ( X , Y )] edges = [( iv , iv + 1 ) for iv in range ( len ( verts ) - 1 )] faces = [ range ( len ( verts ))] mesh = bpy . data . meshes . new ( \"disk_mesh\" ) ob = bpy . data . objects . new ( \"disk\" , mesh ) mesh . from_pydata ( verts , edges , faces ) bpy . context . collection . objects . link ( ob )","title":"Exercise 3: a filled disc from scratch"},{"location":"answers/#exercise-4-making-triangles-and-make-a-vertex-color-layer","text":"Let's take the triangle we made in section 4.1, but let's add another triangle to it, attached to the first. The code would look like this: import bpy # Create a new mesh ob_name = \"triangle\" mesh = bpy . data . meshes . new ( ob_name + \"_mesh\" ) # Create a new object with the mesh ob = bpy . data . objects . new ( ob_name , mesh ) # Define some geometry verts = [ ( 0 , 0 , 0 ), ( 0 , 2 , 0 ), ( 0 , 1 , 2 ) , ( 0 , 3 , 2 ) ] edges = [ ( 0 , 1 ), ( 1 , 2 ), ( 2 , 0 ), ( 1 , 3 ), ( 3 , 2 ) ] # These are indices pointing to elements in the list verts faces = [ ( 0 , 1 , 2 ), ( 1 , 3 , 2 ) ] # These are indices pointing to elements in the list verts # Add it to the mesh mesh . from_pydata ( verts , edges , faces ) # Link the object to the first collection bpy . data . collections [ 0 ] . objects . link ( ob ) Now make a vertex color layer for your triangles. Then inspect how many entries are in color_layer = mesh.vertex_colors['vert_colors'] . Why are they the same or different from the total number of vertices in the mesh? Answer: vertex_colors_name = \"vert_colors\" mesh . vertex_colors . new ( name = vertex_colors_name ) color_layer = mesh . vertex_colors [ vertex_colors_name ] >>> len ( color_layer . data ) 6","title":"Exercise 4: making triangles and make a vertex color layer"},{"location":"answers/#exercise-5-coloring-your-triangles","text":"Let's take the two connected triangles of exercise 4. We will color them in two different ways, using vertex coloring and Python scripting. a) Make the first triangle (face (0,1,2)) green and the second (face (1,3,2)) red. b) Now color vertex (0,0,0) and (0,3,2) red and (0,2,0) and (0,1,2) green to make it look like in Fig.4. Answer: if exercise == \"a\" : vert_colors = [ [ 0 , 1 , 0 , 1 ], [ 0 , 1 , 0 , 1 ], [ 0 , 1 , 0 , 1 ], [ 1 , 0 , 0 , 1 ], [ 1 , 0 , 0 , 1 ] , [ 1 , 0 , 0 , 1 ] ] else : vert_colors = [ [ 1 , 0 , 0 , 1 ], [ 0 , 1 , 0 , 1 ], [ 0 , 1 , 0 , 1 ], [ 1 , 0 , 0 , 1 ] ] for poly in mesh . polygons : for vert_i_poly , vert_i_mesh in enumerate ( poly . vertices ): #loop_indices: vert_i_loop = poly . loop_indices [ vert_i_poly ] if exercise == \"a\" : color_layer . data [ vert_i_loop ] . color = vert_colors [ vert_i_loop ] #rgb else : color_layer . data [ vert_i_loop ] . color = vert_colors [ vert_i_mesh ] print ( poly , vert_i_poly , vert_i_mesh )","title":"Exercise 5: coloring your triangles"},{"location":"api_basics/","text":"2. Blender API basics \u00b6 2.1 Introduction \u00b6 Blender contains a Python interpreter that, at startup, runs scripts to construct the interface and run internal tools. The user can run scripts directly on this interpreter and also access modules provided by Blender like bpy and mathutils . The bpy module gives access to Blender's data, functions and classes. In this section we will focus on using the Python API for automation, custom data import and manipulating geometry, but this is not all that is possible with the API, of course. The official API manual states the following items are possible within the Python API: Edit any data the user interface can (Scenes, Meshes, Particles etc.). Modify user preferences, key-maps and themes. Run tools with own settings. Create user interface elements such as menus, headers and panels. Create new tools. Create interactive tools. Create new rendering engines that integrate with Blender. Subscribe to changes to data and it's properties. Define new settings in existing Blender data. Draw in the 3D view using Python. Before we continue, we list some bits of information and some tricks that are good to know. Blender uses Python 3.x since Blender 2.5; some online documentation still assumes 2.x. You can access the online API documentation from within Blender with Help > Python API Reference Starting Blender from the console will allow you to see important outputs channels (warnings, exceptions, print() statements, etc). See the next section how to do this. The Python Console area in Blender is great for testing Python one-liners. It also has auto-completion so you can inspect the API quickly. In Blender you can hover over almost any button, option, menu, etc and after a second a tool-tip is shown. This tool-tip shows information on how to use this element in the Python API. Right clicking on almost any button, option, menu, etc in Blender gives you the option to 1) directly go to the API documentation with Online Manual or 2) Copy Data Path . Option 2 copies Python API properties related to that element to your clipboard to paste into your script. Note however, that not always the full path is copied, but only the last part. In the upcoming sections we will first look at how to run Python scripts in Blender. Then we look at how to access Blenders data through scripts and we follow this up with creating geometry, vertex colors and materials in the last section. 2.2 Starting Blender from the command line \u00b6 It is important, when scripting, to start Blender from a command line interface (macOS and Linux). Warnings, messages and print() statements will output into the console. How to start Blender from the command line depends on your operating system. For Mac it would be like this: # First, open a terminal window /Applications/Blender.app/Contents/MacOS/Blender For Linux it would be something like: $ <blender installation directory>/blender In Windows you can use Window => Toggle System Console to open the console from the Blender interface, so you don't need to start Blender from the command line More information on where the Blender executable is located on your system and where Blender directories of interest are located see this manual page: https://docs.blender.org/manual/en/dev/advanced/blender_directory_layout.html 2.2.1 Exercise 1: starting Blender from the console \u00b6 Find the Blender executable on the machine you are working on. Open Blender through the console. Delete the cube in the default project of Blender, what output is shown in the console? 2.3 Run scripts within the Blender interface \u00b6 When scripting inside Blender it is convenient to use the Scripting workspace (Fig. 1: see the arrow). It gives you a Python Console (Fig 1: A) and a Text Editor (Fig 1: B). Running scripts within Blender you have a two main options: Interactive Python Console in the Blender interface (Fig. 1: A) Use the built-in Text Editor (Fig. 1: B) The Python Console is nice for exploring the API using auto-complete ( TAB in 2.82+, Ctrl-Space in older versions) to see what is available. The keyboard shortcuts are a bit different than you might be used to in other text editors. See this section in the Blender manual for an overview of menu options and shortcut keys. Blender also has its own built-in editor which you can use (Fig. 1: B) and directly execute the script by pressing Run Script at the top right. If you want to use your own editor to edit your scripts you can do this by opening the script in both the Blender Text Editor and your own editor. To refresh the Blender Text Editor use Text > Reload or Alt R (or Option R on the Mac). You can also make a script that you open in the Blender Text Editor that executes an external script you edit in your own editor. See for example the script in Fig. 1: B. Figure 1: The Scripting workspace in Blender 2.4 Run scripts from the command-line \u00b6 You can also run Python scripts in Blender directly from the command-line interface. An example of executing a script ( -P ) without opening the Blender GUI ( -b , for background) on a Mac would be: blender -b -P script.py Or if you want to render the first frame ( -f 1 ) from the test.blend file. The output will go to the directory of the blender file ( -o //... ) and it will generate a PNG image file ( -F PNG ). blender -b test.blend -o //render_ -F PNG -f 1 More information on command line arguments is here: https://docs.blender.org/manual/en/latest/advanced/command_line/arguments.html 2.5 Load modules in Blender \u00b6 You can add startup scripts to your Blender installation. These scripts can then be easily imported into your script. These scripts can be placd here: scripts /startup/ in the Blender directory (for example on a Mac: /Applications/Blender.app/Contents/Resources/2.81/scripts /startup/ ). For scripts you want to import for just one project or Blender file you can use the normal Python method of editing sys.path : import sys sys . path . append ( \"/some_directory/\" ) import python_module Tip The official binaries of Blender from blender.org include the numpy Python module, so import numpy should work out of the box","title":"Blender API basics"},{"location":"api_basics/#2-blender-api-basics","text":"","title":"2. Blender API basics"},{"location":"api_basics/#21-introduction","text":"Blender contains a Python interpreter that, at startup, runs scripts to construct the interface and run internal tools. The user can run scripts directly on this interpreter and also access modules provided by Blender like bpy and mathutils . The bpy module gives access to Blender's data, functions and classes. In this section we will focus on using the Python API for automation, custom data import and manipulating geometry, but this is not all that is possible with the API, of course. The official API manual states the following items are possible within the Python API: Edit any data the user interface can (Scenes, Meshes, Particles etc.). Modify user preferences, key-maps and themes. Run tools with own settings. Create user interface elements such as menus, headers and panels. Create new tools. Create interactive tools. Create new rendering engines that integrate with Blender. Subscribe to changes to data and it's properties. Define new settings in existing Blender data. Draw in the 3D view using Python. Before we continue, we list some bits of information and some tricks that are good to know. Blender uses Python 3.x since Blender 2.5; some online documentation still assumes 2.x. You can access the online API documentation from within Blender with Help > Python API Reference Starting Blender from the console will allow you to see important outputs channels (warnings, exceptions, print() statements, etc). See the next section how to do this. The Python Console area in Blender is great for testing Python one-liners. It also has auto-completion so you can inspect the API quickly. In Blender you can hover over almost any button, option, menu, etc and after a second a tool-tip is shown. This tool-tip shows information on how to use this element in the Python API. Right clicking on almost any button, option, menu, etc in Blender gives you the option to 1) directly go to the API documentation with Online Manual or 2) Copy Data Path . Option 2 copies Python API properties related to that element to your clipboard to paste into your script. Note however, that not always the full path is copied, but only the last part. In the upcoming sections we will first look at how to run Python scripts in Blender. Then we look at how to access Blenders data through scripts and we follow this up with creating geometry, vertex colors and materials in the last section.","title":"2.1 Introduction"},{"location":"api_basics/#22-starting-blender-from-the-command-line","text":"It is important, when scripting, to start Blender from a command line interface (macOS and Linux). Warnings, messages and print() statements will output into the console. How to start Blender from the command line depends on your operating system. For Mac it would be like this: # First, open a terminal window /Applications/Blender.app/Contents/MacOS/Blender For Linux it would be something like: $ <blender installation directory>/blender In Windows you can use Window => Toggle System Console to open the console from the Blender interface, so you don't need to start Blender from the command line More information on where the Blender executable is located on your system and where Blender directories of interest are located see this manual page: https://docs.blender.org/manual/en/dev/advanced/blender_directory_layout.html","title":"2.2 Starting Blender from the command line"},{"location":"api_basics/#221-exercise-1-starting-blender-from-the-console","text":"Find the Blender executable on the machine you are working on. Open Blender through the console. Delete the cube in the default project of Blender, what output is shown in the console?","title":"2.2.1 Exercise 1: starting Blender from the console"},{"location":"api_basics/#23-run-scripts-within-the-blender-interface","text":"When scripting inside Blender it is convenient to use the Scripting workspace (Fig. 1: see the arrow). It gives you a Python Console (Fig 1: A) and a Text Editor (Fig 1: B). Running scripts within Blender you have a two main options: Interactive Python Console in the Blender interface (Fig. 1: A) Use the built-in Text Editor (Fig. 1: B) The Python Console is nice for exploring the API using auto-complete ( TAB in 2.82+, Ctrl-Space in older versions) to see what is available. The keyboard shortcuts are a bit different than you might be used to in other text editors. See this section in the Blender manual for an overview of menu options and shortcut keys. Blender also has its own built-in editor which you can use (Fig. 1: B) and directly execute the script by pressing Run Script at the top right. If you want to use your own editor to edit your scripts you can do this by opening the script in both the Blender Text Editor and your own editor. To refresh the Blender Text Editor use Text > Reload or Alt R (or Option R on the Mac). You can also make a script that you open in the Blender Text Editor that executes an external script you edit in your own editor. See for example the script in Fig. 1: B. Figure 1: The Scripting workspace in Blender","title":"2.3 Run scripts within the Blender interface"},{"location":"api_basics/#24-run-scripts-from-the-command-line","text":"You can also run Python scripts in Blender directly from the command-line interface. An example of executing a script ( -P ) without opening the Blender GUI ( -b , for background) on a Mac would be: blender -b -P script.py Or if you want to render the first frame ( -f 1 ) from the test.blend file. The output will go to the directory of the blender file ( -o //... ) and it will generate a PNG image file ( -F PNG ). blender -b test.blend -o //render_ -F PNG -f 1 More information on command line arguments is here: https://docs.blender.org/manual/en/latest/advanced/command_line/arguments.html","title":"2.4 Run scripts from the command-line"},{"location":"api_basics/#25-load-modules-in-blender","text":"You can add startup scripts to your Blender installation. These scripts can then be easily imported into your script. These scripts can be placd here: scripts /startup/ in the Blender directory (for example on a Mac: /Applications/Blender.app/Contents/Resources/2.81/scripts /startup/ ). For scripts you want to import for just one project or Blender file you can use the normal Python method of editing sys.path : import sys sys . path . append ( \"/some_directory/\" ) import python_module Tip The official binaries of Blender from blender.org include the numpy Python module, so import numpy should work out of the box","title":"2.5 Load modules in Blender"},{"location":"contact/","text":"6. Contact & information \u00b6 What Where Course page https://surfsara-visualization.github.io/blendercourses Discord server https://discord.gg/mVjYzbm","title":"Contact & information"},{"location":"contact/#6-contact-information","text":"What Where Course page https://surfsara-visualization.github.io/blendercourses Discord server https://discord.gg/mVjYzbm","title":"6. Contact &amp; information"},{"location":"examples_exercises/","text":"Exercise X: making a cube from scratch \u00b6 If you blender -b test.blend -o .//render_ -F PNG -f 1","title":"Examples exercises"},{"location":"examples_exercises/#exercise-x-making-a-cube-from-scratch","text":"If you blender -b test.blend -o .//render_ -F PNG -f 1","title":"Exercise X: making a cube from scratch"},{"location":"final_project/","text":"5. Final project: making a visualisation of your own data \u00b6 We would like you to spend the remainder of your time in this course on doing this little project. We have two options for you to choose from. The first and recommended one is making a visualisation of your own (research) data. The second option is that you work on a visualisation of data we have prepared. Do not forget that if you are stuck join us on Discord or in a feedback webinar so we can help. See the course page for more information. If you made a nice visualisation and still have time left in the course, why not make an animation? 5.1 Option 1: your own data \u00b6 So far you have learned how to make meshes and vertex colors in Blender using Python. So, think about if you can visualise your data using these techniques. You need to think about what you need to do to transform your data into a form that can be used to generate vertices, faces and vertex colors. And how do you want to visualise your data values? Can you visualise them through the cartesian coordinates of the vertices and faces and maybe some colors? Do you need to use vertex coloring? Or do you need something else? Note that volumetric data will be difficult in Blender and you may need to think of some tricks. 5.2 Option 2: visualise a computer model of a proto-planetary disk \u00b6 Although we highly recommend you to work on your own data, if you have none to use, you can use the following data to work on. Here we give a brief introduction on the data. 5.2.1 What is a proto-planetary disk \u00b6 A proto-planetary disk is a disk-like structure around a newly born star. This disk is filled with dust (solid-state particles with a diameter in the order of 1 micrometer) and gas. In the course of time this dust and gas can coalesce into planets. In this option we will look at a computer model of the dust in such a disk. The model calculates the temperature and density of the dust in the disk, taking the radiation and gravity of the star into account. The calculations of the software (called MCMax ) is done iteratively and using Monte Carlo techniques. Packages of photons are emitted by the star in random directions and their wavelength sampled from the radiation distribution of the star (by default a blackbody). Using the absorption, scattering and emission properties used for the dust grains in the disk, the scattering, absorption and re-emission of the photons are calculated throughout the disk. This is used to calculate a temperature structure in the disk. This temperature is then used to adapt the starting density structure of the disk after which a new pass is done by tracking a next set of photons and adapting the density subsequently. This is repeated until convergence is reached. The code uses a two dimensional (adaptable) grid in the radial and theta direction. The disk is assumed to be cylindrically symmetric around the polar axis (z-axis, see Fig. 1). The grid cell size is lowered in regions where the density becomes high. Figure 1: definition of coordinates 5.2.2 How to start visualising such a proto-planetary disk \u00b6 You could create a 3D model of the disk at constant density and display the temperature as colors on the surface of the model. You could use this to make nice renders and animations to show the temperature structure of the disk. For this we need to pre-process the data from the model to get the spatial coordinates of the disk at a constant density. These coordinates then need to be converted into cartesian coordinates of vertices and faces before creating the geometry in Blender. You can then add the temperatures to the faces using vertex coloring and by adding the needed shaders to the model. 5.2.3 How the model data is structured \u00b6 You can download the data here . An example output file of modeling code MCMax is shown below. # Format number 5 # NR , NT , NGRAINS , NGRAINS2 100 100 1 1 # Spherical radius grid [ cm ] ( middle of cell ) 7479900216981.22 7479900572789.07 [ ... ] # Theta grid [ rad, from pole ] ( middle of cell ) 9.233559849414326E-003 2.365344804038962E-002 [ ... ] # Density array ( for ir = 0 , nr - 1 do for it = 0 , nt - 1 do ...) 1.001753516582521E-050 1.001753516582521E-050 [ ... ] # Temperature array ( for ir = 0 , nr - 1 do for it = 0 , nt - 1 do ...) 1933.54960366819 1917.22966277529 [ ... ] # Composition array ( for ir = 0 , nr - 1 do for it = 0 , nt - 1 do ...) 1.00000000000000 1.00000000000000 [ ... ] # Gas density array ( for ir = 0 , nr - 1 do for it = 0 , nt - 1 do ...) 1.001753516582521E-048 1.001753516582521E-048 [ ... ] # Density0 array ( for ir = 0 , nr - 1 do for it = 0 , nt - 1 do ...) 1.001753516582521E-050 1.001753516582521E-050 [ ... ] The file is structured in a way the scientist thought best at the time using the tools at hand. For us it is important to notice the NR and NT , which stands for number of radial and theta points respectively (NGRAINS is related to the number of different types of dust grains in the disk and you can ignore this). Further, the output file then lists the radius points and after that the theta points. Subsequently temperature and density values are listed by iterating over the radius and then the theta indices. The units of all the values in the MCMax output are: R[cm], Theta[radians], Density[gr/cm^3], Temperature[K]. The data from the MCMax code is in spherical coordinates, while the system in Blender works with cartesian coordinates. The theta in the output is defined as the angle with the z-axis (See Fig. 1).","title":"Final project"},{"location":"final_project/#5-final-project-making-a-visualisation-of-your-own-data","text":"We would like you to spend the remainder of your time in this course on doing this little project. We have two options for you to choose from. The first and recommended one is making a visualisation of your own (research) data. The second option is that you work on a visualisation of data we have prepared. Do not forget that if you are stuck join us on Discord or in a feedback webinar so we can help. See the course page for more information. If you made a nice visualisation and still have time left in the course, why not make an animation?","title":"5. Final project: making a visualisation of your own data"},{"location":"final_project/#51-option-1-your-own-data","text":"So far you have learned how to make meshes and vertex colors in Blender using Python. So, think about if you can visualise your data using these techniques. You need to think about what you need to do to transform your data into a form that can be used to generate vertices, faces and vertex colors. And how do you want to visualise your data values? Can you visualise them through the cartesian coordinates of the vertices and faces and maybe some colors? Do you need to use vertex coloring? Or do you need something else? Note that volumetric data will be difficult in Blender and you may need to think of some tricks.","title":"5.1 Option 1: your own data"},{"location":"final_project/#52-option-2-visualise-a-computer-model-of-a-proto-planetary-disk","text":"Although we highly recommend you to work on your own data, if you have none to use, you can use the following data to work on. Here we give a brief introduction on the data.","title":"5.2 Option 2: visualise a computer model of a proto-planetary disk"},{"location":"final_project/#521-what-is-a-proto-planetary-disk","text":"A proto-planetary disk is a disk-like structure around a newly born star. This disk is filled with dust (solid-state particles with a diameter in the order of 1 micrometer) and gas. In the course of time this dust and gas can coalesce into planets. In this option we will look at a computer model of the dust in such a disk. The model calculates the temperature and density of the dust in the disk, taking the radiation and gravity of the star into account. The calculations of the software (called MCMax ) is done iteratively and using Monte Carlo techniques. Packages of photons are emitted by the star in random directions and their wavelength sampled from the radiation distribution of the star (by default a blackbody). Using the absorption, scattering and emission properties used for the dust grains in the disk, the scattering, absorption and re-emission of the photons are calculated throughout the disk. This is used to calculate a temperature structure in the disk. This temperature is then used to adapt the starting density structure of the disk after which a new pass is done by tracking a next set of photons and adapting the density subsequently. This is repeated until convergence is reached. The code uses a two dimensional (adaptable) grid in the radial and theta direction. The disk is assumed to be cylindrically symmetric around the polar axis (z-axis, see Fig. 1). The grid cell size is lowered in regions where the density becomes high. Figure 1: definition of coordinates","title":"5.2.1 What is a proto-planetary disk"},{"location":"final_project/#522-how-to-start-visualising-such-a-proto-planetary-disk","text":"You could create a 3D model of the disk at constant density and display the temperature as colors on the surface of the model. You could use this to make nice renders and animations to show the temperature structure of the disk. For this we need to pre-process the data from the model to get the spatial coordinates of the disk at a constant density. These coordinates then need to be converted into cartesian coordinates of vertices and faces before creating the geometry in Blender. You can then add the temperatures to the faces using vertex coloring and by adding the needed shaders to the model.","title":"5.2.2 How to start visualising such a proto-planetary disk"},{"location":"final_project/#523-how-the-model-data-is-structured","text":"You can download the data here . An example output file of modeling code MCMax is shown below. # Format number 5 # NR , NT , NGRAINS , NGRAINS2 100 100 1 1 # Spherical radius grid [ cm ] ( middle of cell ) 7479900216981.22 7479900572789.07 [ ... ] # Theta grid [ rad, from pole ] ( middle of cell ) 9.233559849414326E-003 2.365344804038962E-002 [ ... ] # Density array ( for ir = 0 , nr - 1 do for it = 0 , nt - 1 do ...) 1.001753516582521E-050 1.001753516582521E-050 [ ... ] # Temperature array ( for ir = 0 , nr - 1 do for it = 0 , nt - 1 do ...) 1933.54960366819 1917.22966277529 [ ... ] # Composition array ( for ir = 0 , nr - 1 do for it = 0 , nt - 1 do ...) 1.00000000000000 1.00000000000000 [ ... ] # Gas density array ( for ir = 0 , nr - 1 do for it = 0 , nt - 1 do ...) 1.001753516582521E-048 1.001753516582521E-048 [ ... ] # Density0 array ( for ir = 0 , nr - 1 do for it = 0 , nt - 1 do ...) 1.001753516582521E-050 1.001753516582521E-050 [ ... ] The file is structured in a way the scientist thought best at the time using the tools at hand. For us it is important to notice the NR and NT , which stands for number of radial and theta points respectively (NGRAINS is related to the number of different types of dust grains in the disk and you can ignore this). Further, the output file then lists the radius points and after that the theta points. Subsequently temperature and density values are listed by iterating over the radius and then the theta indices. The units of all the values in the MCMax output are: R[cm], Theta[radians], Density[gr/cm^3], Temperature[K]. The data from the MCMax code is in spherical coordinates, while the system in Blender works with cartesian coordinates. The theta in the output is defined as the angle with the z-axis (See Fig. 1).","title":"5.2.3 How the model data is structured"},{"location":"geometry_colors_and_materials/","text":"4. Creating geometry, colors and materials \u00b6 4.1 Creating an object with a mesh \u00b6 If we want to create a new mesh we can do this by calling the new function like this: mesh = bpy . data . meshes . new ( \"newMesh\" ) This will create the mesh but it is not linked to an object (it will not show in the Outliner ). So we make a new object and link the object to the mesh: obj = bpy . data . objects . new ( \"newObject\" , mesh ) We can actually verify this worked correctly by checking the value of obj.data : >>> obj.data bpy.data.meshes['newMesh'] If you check the Outliner in the user interface you will see both the object newObject and the mesh newMesh linked to it. Now we have an empty mesh, linked to an object. We will now construct a simple piece geometry to show how this is done in Blender. Vertices are defined by their x, y and z values like this: verts = [ ( 0 , 0 , 0 ), ( 0 , 2 , 0 ), ( 0 , 1 , 2 ) ] Edges are defined as a tuple holding two indices pointing to two vertices in the verts list. So (0,1) refers to a line from vertex (0,0,0) (index 0 in verts ) to (0,2,0) (index 1 in verts ) in this example. We make the following edges: edges = [ ( 0 , 1 ), ( 1 , 2 ), ( 2 , 0 ) ] To make faces we need three or more vertices. Per face you make a tuple of three or more indices pointing to three vertices in the verts list. For example the face (0,1,2) is a face made up from the vertices (0,0,0), (0,2,0) and (0,1,2), which are at index 0, 1 and 2 in the verts list. For now lets make one face: faces = [ ( 0 , 1 , 2 ) ] We now use a function from the Python API to make a mesh from our verts, edges and faces: mesh . from_pydata ( verts , edges , faces ) Now the mesh and the object are created, but it does not yet show in the 3D viewport or the Outliner . This is because we still need to link the new object to an existing collection and in so doing to a scene. bpy . data . collections [ 0 ] . objects . link ( obj ) To summarize here is the full code to generate this geometry: import bpy # Create a new mesh ob_name = \"triangle\" mesh = bpy . data . meshes . new ( ob_name + \"_mesh\" ) # Create a new object with the mesh ob = bpy . data . objects . new ( ob_name , mesh ) # Define some geometry verts = [ ( 0 , 0 , 0 ), ( 0 , 2 , 0 ), ( 0 , 1 , 2 ) ] edges = [ ( 0 , 1 ), ( 1 , 2 ), ( 2 , 0 ) ] # These are indices pointing to elements in the list verts faces = [ ( 0 , 1 , 2 ) ] # These are indices pointing to elements in the list verts # Add it to the mesh mesh . from_pydata ( verts , edges , faces ) # Link the object to the first collection bpy . data . collections [ 0 ] . objects . link ( ob ) Tips Note that in general you do not need to explicitly specify edges, as these will be generated automatically based on the faces specified. It's only when you want to have edges that are not connected to faces that you need to specify them explicitly. All objects in Blender (and object data of the same type, i.e. all meshes) are enforced to have unique names. When using the Python API this is no different. So if you create an object with bpy.data.objects.new(\"obj\", mesh) and there already is an object named \"obj\" the name of the new object will be automatically set to something else. This can become important if you generate many objects (say in a loop) but still want to be able to refer to them later by name. 4.2 Exercise 3: a filled disk from scratch \u00b6 In the text above we created a triangle, now as an exercise let's create a spherical disk. First create a ring of vertices, then create edges and a face. 4.3 Adding vertex colors to a mesh \u00b6 Vertex coloring is a way to color a mesh without using textures or uv-mapping. It works by assigning for every face that a vertex is a member of a color to that vertex. So a vertex can have different colors for each of the different faces it is in. Let's say we have a mesh, named \"triangle_mesh\": mesh = bpy.data.meshes['triangle_mesh'] , the vertex colors for this mesh will be stored in mesh.vertex_colors . If the mesh does not have a vertex color layer yet, you can make a new one with: mesh.vertex_colors.new(name='vert_colors') . Now we have a color layer to work with: color_layer = mesh.vertex_colors['vert_colors'] . 4.4 Exercise 4: making triangles and make a vertex color layer \u00b6 Let's take the triangle we made in section 4.1, but let's add another triangle to it, attached to the first. The code would look like this: import bpy # Create a new mesh ob_name = \"triangle\" mesh = bpy . data . meshes . new ( ob_name + \"_mesh\" ) # Create a new object with the mesh ob = bpy . data . objects . new ( ob_name , mesh ) # Define some geometry verts = [ ( 0 , 0 , 0 ), ( 0 , 2 , 0 ), ( 0 , 1 , 2 ) , ( 0 , 3 , 2 ) ] edges = [ ( 0 , 1 ), ( 1 , 2 ), ( 2 , 0 ), ( 1 , 3 ), ( 3 , 2 ) ] # These are indices pointing to elements in the list verts faces = [ ( 0 , 1 , 2 ), ( 1 , 3 , 2 ) ] # These are indices pointing to elements in the list verts # Add it to the mesh mesh . from_pydata ( verts , edges , faces ) # Link the object to the first collection bpy . data . collections [ 0 ] . objects . link ( ob ) Now make a vertex color layer for your triangles. Then inspect how many entries are in color_layer = mesh.vertex_colors['vert_colors'] . Why are they the same or different from the total number of vertices in the mesh? In exercise 4 we saw that color_layer.data contains six entries while we only have four vertices in the mesh. This is because a vertex has a color for every face it is in. So vertex (0,2,0) and (0,1,2) are each in two faces, while the other two vertices are only in one face. So the former vertices have two entries in the color layer, one for each face they are in, the latter only one color entry. The link between vertex indices in a mesh and those in the vertex color layer can be deduced from the polygons in mesh.polygons . Let's take one polygon from the triangles, lets say the first ( poly = mesh.polygons[0] ). Now, for one vertex in the polygon, poly.vertices gives you the index of the vertex in the mesh and poly.loop_indices gives you the index of the vertex in color_layer.data . See Fig. 3. Figure 3: Sketch of the two triangles from Exercise 4. For the vertices are shown the coordinates (in black italic (x, x, x)), indices of the vertex in its mesh (green, outside of the face) and the indices in the loop_indices of the polygon (red, italic and inside the faces. Once you have set colors for your vertices you need to set up the shader of the object 1 . For this go to the Shading workspace. Create a Vertex Color node and connect it to a Principled BSDF (connect Color output to Base Color input). And then make a Material Output and connect the Principled BSDF to the Surface input of the Material Output . See Fig. 4. Figure 4: Shader setup for vertex colors 4.5 Exercise 5: coloring your triangles \u00b6 Let's take the two connected triangles of exercise 4. We will color them in two different ways, using vertex coloring and Python scripting. a) Make the first triangle (face (0,1,2)) green and the second (face (1,3,2)) red. b) Now color vertex (0,0,0) and (0,3,2) red and (0,2,0) and (0,1,2) green to make it look like in Fig.4. 4.6 Adding a material \u00b6 You can also add materials through the Python API. As an example to show how you could do this, let's add a material to the triangle from exercise 4 in the last section. Materials are stored in bpy.data.material and we can make a new material: # Make material triangle_material_name = \"triangle_mat\" mat = bpy . data . materials . new ( triangle_material_name ) The nodes and the node tree are stored in the material 1 . mat . use_nodes = True nodes = mat . node_tree . nodes Before we start making nodes we remove the automatically generated nodes. nodes . clear () We will make two nodes, one Principled BSDF shader and an output node. We can make the shader by making a new node. shader = nodes . new ( type = 'ShaderNodeBsdfPrincipled' ) How a node type is called you can search up in Blender in the following way. Go to the Shading workspace and open the add menu in the Shader Editor . Now go to Shader and hover over Principled BSDF until an information pop-up appears. In the pop-up you can find how the node type is called. See Fig. 5. Figure 5: The type name of a node can be found by navigating to the Add menu and hovering over the node of your interest If you also want to organize the nodes in the Shader Editor you can place the node like this: shader . location = 0 , 300 # Location in the node window We can set the inputs of the Principled BSDF shader to a default_value. shader . inputs [ 0 ] . default_value = ( 1 , 0 , 0 , 1 ) We can now also make an output node and place it in the Shader Editor . node_output = nodes . new ( type = 'ShaderNodeOutputMaterial' ) node_output . location = 400 , 300 Links between nodes can be made using the links in the node_tree. A new link will take outputs and inputs from the nodes you want to link. links = mat . node_tree . links links . new ( shader . outputs [ 0 ], node_output . inputs [ 0 ]) Now we only need to add the material to the mesh containing the spherical disk. mesh . materials . append ( mat ) In summary, the total code for making the material is: # Make material triangle_material_name = \"triangle_mat\" mat = bpy . data . materials . new ( triangle_material_name ) mat . use_nodes = True nodes = mat . node_tree . nodes # Clear default nodes nodes . clear () shader = nodes . new ( type = 'ShaderNodeBsdfPrincipled' ) shader . location = 0 , 300 # Location in the node window shader . inputs [ 0 ] . default_value = ( 1 , 0 , 0 , 1 ) # Create an output for the shader node_output = nodes . new ( type = 'ShaderNodeOutputMaterial' ) node_output . location = 400 , 300 links = mat . node_tree . links links . new ( shader . outputs [ 0 ], node_output . inputs [ 0 ]) mesh . materials . append ( mat ) Although we make minimal use of shading in this chapter, you might not be familiar with shading and materials in Blender. Here is a great introduction of how to use materials in Blender. \u21a9 \u21a9","title":"Creating geometry, colors and materials"},{"location":"geometry_colors_and_materials/#4-creating-geometry-colors-and-materials","text":"","title":"4. Creating geometry, colors and materials"},{"location":"geometry_colors_and_materials/#41-creating-an-object-with-a-mesh","text":"If we want to create a new mesh we can do this by calling the new function like this: mesh = bpy . data . meshes . new ( \"newMesh\" ) This will create the mesh but it is not linked to an object (it will not show in the Outliner ). So we make a new object and link the object to the mesh: obj = bpy . data . objects . new ( \"newObject\" , mesh ) We can actually verify this worked correctly by checking the value of obj.data : >>> obj.data bpy.data.meshes['newMesh'] If you check the Outliner in the user interface you will see both the object newObject and the mesh newMesh linked to it. Now we have an empty mesh, linked to an object. We will now construct a simple piece geometry to show how this is done in Blender. Vertices are defined by their x, y and z values like this: verts = [ ( 0 , 0 , 0 ), ( 0 , 2 , 0 ), ( 0 , 1 , 2 ) ] Edges are defined as a tuple holding two indices pointing to two vertices in the verts list. So (0,1) refers to a line from vertex (0,0,0) (index 0 in verts ) to (0,2,0) (index 1 in verts ) in this example. We make the following edges: edges = [ ( 0 , 1 ), ( 1 , 2 ), ( 2 , 0 ) ] To make faces we need three or more vertices. Per face you make a tuple of three or more indices pointing to three vertices in the verts list. For example the face (0,1,2) is a face made up from the vertices (0,0,0), (0,2,0) and (0,1,2), which are at index 0, 1 and 2 in the verts list. For now lets make one face: faces = [ ( 0 , 1 , 2 ) ] We now use a function from the Python API to make a mesh from our verts, edges and faces: mesh . from_pydata ( verts , edges , faces ) Now the mesh and the object are created, but it does not yet show in the 3D viewport or the Outliner . This is because we still need to link the new object to an existing collection and in so doing to a scene. bpy . data . collections [ 0 ] . objects . link ( obj ) To summarize here is the full code to generate this geometry: import bpy # Create a new mesh ob_name = \"triangle\" mesh = bpy . data . meshes . new ( ob_name + \"_mesh\" ) # Create a new object with the mesh ob = bpy . data . objects . new ( ob_name , mesh ) # Define some geometry verts = [ ( 0 , 0 , 0 ), ( 0 , 2 , 0 ), ( 0 , 1 , 2 ) ] edges = [ ( 0 , 1 ), ( 1 , 2 ), ( 2 , 0 ) ] # These are indices pointing to elements in the list verts faces = [ ( 0 , 1 , 2 ) ] # These are indices pointing to elements in the list verts # Add it to the mesh mesh . from_pydata ( verts , edges , faces ) # Link the object to the first collection bpy . data . collections [ 0 ] . objects . link ( ob ) Tips Note that in general you do not need to explicitly specify edges, as these will be generated automatically based on the faces specified. It's only when you want to have edges that are not connected to faces that you need to specify them explicitly. All objects in Blender (and object data of the same type, i.e. all meshes) are enforced to have unique names. When using the Python API this is no different. So if you create an object with bpy.data.objects.new(\"obj\", mesh) and there already is an object named \"obj\" the name of the new object will be automatically set to something else. This can become important if you generate many objects (say in a loop) but still want to be able to refer to them later by name.","title":"4.1 Creating an object with a mesh"},{"location":"geometry_colors_and_materials/#42-exercise-3-a-filled-disk-from-scratch","text":"In the text above we created a triangle, now as an exercise let's create a spherical disk. First create a ring of vertices, then create edges and a face.","title":"4.2 Exercise 3: a filled disk from scratch"},{"location":"geometry_colors_and_materials/#43-adding-vertex-colors-to-a-mesh","text":"Vertex coloring is a way to color a mesh without using textures or uv-mapping. It works by assigning for every face that a vertex is a member of a color to that vertex. So a vertex can have different colors for each of the different faces it is in. Let's say we have a mesh, named \"triangle_mesh\": mesh = bpy.data.meshes['triangle_mesh'] , the vertex colors for this mesh will be stored in mesh.vertex_colors . If the mesh does not have a vertex color layer yet, you can make a new one with: mesh.vertex_colors.new(name='vert_colors') . Now we have a color layer to work with: color_layer = mesh.vertex_colors['vert_colors'] .","title":"4.3 Adding vertex colors to a mesh"},{"location":"geometry_colors_and_materials/#44-exercise-4-making-triangles-and-make-a-vertex-color-layer","text":"Let's take the triangle we made in section 4.1, but let's add another triangle to it, attached to the first. The code would look like this: import bpy # Create a new mesh ob_name = \"triangle\" mesh = bpy . data . meshes . new ( ob_name + \"_mesh\" ) # Create a new object with the mesh ob = bpy . data . objects . new ( ob_name , mesh ) # Define some geometry verts = [ ( 0 , 0 , 0 ), ( 0 , 2 , 0 ), ( 0 , 1 , 2 ) , ( 0 , 3 , 2 ) ] edges = [ ( 0 , 1 ), ( 1 , 2 ), ( 2 , 0 ), ( 1 , 3 ), ( 3 , 2 ) ] # These are indices pointing to elements in the list verts faces = [ ( 0 , 1 , 2 ), ( 1 , 3 , 2 ) ] # These are indices pointing to elements in the list verts # Add it to the mesh mesh . from_pydata ( verts , edges , faces ) # Link the object to the first collection bpy . data . collections [ 0 ] . objects . link ( ob ) Now make a vertex color layer for your triangles. Then inspect how many entries are in color_layer = mesh.vertex_colors['vert_colors'] . Why are they the same or different from the total number of vertices in the mesh? In exercise 4 we saw that color_layer.data contains six entries while we only have four vertices in the mesh. This is because a vertex has a color for every face it is in. So vertex (0,2,0) and (0,1,2) are each in two faces, while the other two vertices are only in one face. So the former vertices have two entries in the color layer, one for each face they are in, the latter only one color entry. The link between vertex indices in a mesh and those in the vertex color layer can be deduced from the polygons in mesh.polygons . Let's take one polygon from the triangles, lets say the first ( poly = mesh.polygons[0] ). Now, for one vertex in the polygon, poly.vertices gives you the index of the vertex in the mesh and poly.loop_indices gives you the index of the vertex in color_layer.data . See Fig. 3. Figure 3: Sketch of the two triangles from Exercise 4. For the vertices are shown the coordinates (in black italic (x, x, x)), indices of the vertex in its mesh (green, outside of the face) and the indices in the loop_indices of the polygon (red, italic and inside the faces. Once you have set colors for your vertices you need to set up the shader of the object 1 . For this go to the Shading workspace. Create a Vertex Color node and connect it to a Principled BSDF (connect Color output to Base Color input). And then make a Material Output and connect the Principled BSDF to the Surface input of the Material Output . See Fig. 4. Figure 4: Shader setup for vertex colors","title":"4.4 Exercise 4: making triangles and make a vertex color layer"},{"location":"geometry_colors_and_materials/#45-exercise-5-coloring-your-triangles","text":"Let's take the two connected triangles of exercise 4. We will color them in two different ways, using vertex coloring and Python scripting. a) Make the first triangle (face (0,1,2)) green and the second (face (1,3,2)) red. b) Now color vertex (0,0,0) and (0,3,2) red and (0,2,0) and (0,1,2) green to make it look like in Fig.4.","title":"4.5 Exercise 5: coloring your triangles"},{"location":"geometry_colors_and_materials/#46-adding-a-material","text":"You can also add materials through the Python API. As an example to show how you could do this, let's add a material to the triangle from exercise 4 in the last section. Materials are stored in bpy.data.material and we can make a new material: # Make material triangle_material_name = \"triangle_mat\" mat = bpy . data . materials . new ( triangle_material_name ) The nodes and the node tree are stored in the material 1 . mat . use_nodes = True nodes = mat . node_tree . nodes Before we start making nodes we remove the automatically generated nodes. nodes . clear () We will make two nodes, one Principled BSDF shader and an output node. We can make the shader by making a new node. shader = nodes . new ( type = 'ShaderNodeBsdfPrincipled' ) How a node type is called you can search up in Blender in the following way. Go to the Shading workspace and open the add menu in the Shader Editor . Now go to Shader and hover over Principled BSDF until an information pop-up appears. In the pop-up you can find how the node type is called. See Fig. 5. Figure 5: The type name of a node can be found by navigating to the Add menu and hovering over the node of your interest If you also want to organize the nodes in the Shader Editor you can place the node like this: shader . location = 0 , 300 # Location in the node window We can set the inputs of the Principled BSDF shader to a default_value. shader . inputs [ 0 ] . default_value = ( 1 , 0 , 0 , 1 ) We can now also make an output node and place it in the Shader Editor . node_output = nodes . new ( type = 'ShaderNodeOutputMaterial' ) node_output . location = 400 , 300 Links between nodes can be made using the links in the node_tree. A new link will take outputs and inputs from the nodes you want to link. links = mat . node_tree . links links . new ( shader . outputs [ 0 ], node_output . inputs [ 0 ]) Now we only need to add the material to the mesh containing the spherical disk. mesh . materials . append ( mat ) In summary, the total code for making the material is: # Make material triangle_material_name = \"triangle_mat\" mat = bpy . data . materials . new ( triangle_material_name ) mat . use_nodes = True nodes = mat . node_tree . nodes # Clear default nodes nodes . clear () shader = nodes . new ( type = 'ShaderNodeBsdfPrincipled' ) shader . location = 0 , 300 # Location in the node window shader . inputs [ 0 ] . default_value = ( 1 , 0 , 0 , 1 ) # Create an output for the shader node_output = nodes . new ( type = 'ShaderNodeOutputMaterial' ) node_output . location = 400 , 300 links = mat . node_tree . links links . new ( shader . outputs [ 0 ], node_output . inputs [ 0 ]) mesh . materials . append ( mat ) Although we make minimal use of shading in this chapter, you might not be familiar with shading and materials in Blender. Here is a great introduction of how to use materials in Blender. \u21a9 \u21a9","title":"4.6 Adding a material"}]}